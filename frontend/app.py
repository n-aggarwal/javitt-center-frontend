import streamlit as st
import requests
import json


def escape_dollar_signs(text):
    """Escape dollar signs to prevent LaTeX rendering in Streamlit markdown."""
    if text:
        return text.replace('$', r'\$')
    return text


st.set_page_config(page_title="Bedrock SQL Agent (Agentic Workflow)", page_icon="ðŸ§ ", layout="wide")

# Backend URL configuration
backend_url = "http://localhost:8000"

st.title("ðŸ§  Bedrock SQL Agent (Agentic Workflow)")

with st.sidebar:
    st.header("About")
    st.markdown("""
    This application uses an **agentic workflow** to automatically:

    - Extract database schema
    - Analyze table relationships
    - Generate data dictionary with AI
    - Cache everything for fast queries

    **No manual setup required!**
    """)

    st.divider()

    st.header("Data Dictionary (Optional)")
    uploaded_file = st.file_uploader(
        "Upload Custom Data Dictionary",
        type=['csv'],
        help="Upload a CSV file with custom column descriptions (coming soon)"
    )

    if uploaded_file is not None:
        st.info("Custom data dictionary upload (coming soon)")

    st.divider()

    st.header("How It Works")
    st.markdown("""
    - **Agent 1:** Extracts schema from database
    - **Agent 2:** Analyzes structure with Bedrock
    - **Agent 3:** Generates data dictionary
    - **Agent 4:** Answers your queries

    The schema and dictionary are generated once and cached.
    """)

# Initialize session state for conversation history
if "history" not in st.session_state:
    st.session_state.history = []  # Stores conversation messages

if "conversation_history" not in st.session_state:
    st.session_state.conversation_history = []  # Stores messages for API

st.subheader("Ask the agent")
user_msg = st.text_area("Your request", placeholder="e.g., How many customers do we have?")

col1, col2 = st.columns([1,1])
with col1:
    run_btn = st.button("Run")
with col2:
    clear_btn = st.button("Clear Conversation")

if clear_btn:
    st.session_state.history = []
    st.session_state.conversation_history = []
    st.rerun()

if run_btn and user_msg.strip():
    try:
        # Prepare request payload (data dictionary is auto-generated by agentic workflow)
        payload = {
            "query": user_msg.strip(),
            "include_explanation": True,
            "conversation_history": st.session_state.conversation_history
        }

        # Call backend API
        with st.spinner("Processing query..."):
            response = requests.post(
                f"{backend_url}/query",
                json=payload,
                timeout=30
            )

        if response.status_code == 200:
            result = response.json()

            # Add user message to history
            st.session_state.history.append({
                "role": "user",
                "content": user_msg.strip()
            })

            # Build assistant response
            if result.get("success"):
                assistant_response = f"""**Generated SQL:**
```sql
{result.get('sql', '')}
```

**Results:**
{result.get('row_count', 0)} rows returned

"""
                # Show sample results
                if result.get('results'):
                    results_preview = result['results'][:5]  # Show first 5 rows
                    assistant_response += f"```json\n{json.dumps(results_preview, indent=2)}\n```\n\n"

                # Add explanation (escape dollar signs to prevent LaTeX rendering)
                if result.get('explanation'):
                    assistant_response += f"**Explanation:**\n{escape_dollar_signs(result['explanation'])}"

                st.session_state.history.append({
                    "role": "assistant",
                    "content": assistant_response,
                    "sql": result.get('sql'),
                    "results": result.get('results')
                })

                # Update conversation history for API (keeping context)
                st.session_state.conversation_history.append({
                    "role": "user",
                    "content": user_msg.strip()
                })
                st.session_state.conversation_history.append({
                    "role": "assistant",
                    "content": result.get('explanation', '') or f"Executed SQL: {result.get('sql')}"
                })

            else:
                # Handle error
                error_msg = f"**Error:** {result.get('error', 'Unknown error')}\n\n"
                if result.get('sql'):
                    error_msg += f"**Generated SQL:**\n```sql\n{result['sql']}\n```\n\n"
                if result.get('explanation'):
                    error_msg += f"**Explanation:**\n{escape_dollar_signs(result['explanation'])}"

                st.session_state.history.append({
                    "role": "assistant",
                    "content": error_msg
                })

            st.success("Query processed!")
            st.rerun()
        else:
            st.error(f"Backend error: {response.status_code} - {response.text}")

    except requests.exceptions.Timeout:
        st.error("Request timed out. Query took too long to process.")
    except requests.exceptions.ConnectionError:
        st.error(f"Could not connect to backend at {backend_url}. Make sure the backend is running.")
    except Exception as e:
        st.error(f"Agent error: {e}")

st.subheader("Conversation")
for msg in st.session_state.history:
    role = msg.get("role")
    content = msg.get("content", "")

    if role == "user":
        st.markdown(f"**User:** {content}")
    elif role == "assistant":
        st.markdown("**Assistant:**")
        st.markdown(content)

        # Show expandable full results if available
        if msg.get("results"):
            with st.expander("View Full Results"):
                st.json(msg["results"])

st.caption("Tip: The conversation maintains context - you can ask follow-up questions like 'what about orders?' or 'show me the top 10'")

st.divider()

st.subheader("Database Information")

# Initialize database info in session state
if "db_info_loaded" not in st.session_state:
    st.session_state.db_info_loaded = False
    st.session_state.db_info = None

col1, col2 = st.columns([3, 1])

with col1:
    if st.button("Load Database Schema & Data Dictionary"):
        try:
            with st.spinner("Loading database information..."):
                response = requests.get(f"{backend_url}/database/info", timeout=30)
                if response.status_code == 200:
                    st.session_state.db_info = response.json()
                    st.session_state.db_info_loaded = True
                    st.success("âœ“ Database schema and data dictionary loaded!")
                    st.rerun()
                else:
                    st.error(f"Error: {response.status_code}")
        except Exception as e:
            st.error(f"Error: {e}")

with col2:
    if st.button("Check Backend Health"):
        try:
            response = requests.get(f"{backend_url}/health", timeout=5)
            if response.status_code == 200:
                health = response.json()
                st.success(f"âœ“ Healthy ({health.get('tables_count', 0)} tables)")
            else:
                st.error(f"Unhealthy: {response.status_code}")
        except Exception as e:
            st.error(f"Error: {e}")

# Display database information if loaded
if st.session_state.db_info_loaded and st.session_state.db_info:
    info = st.session_state.db_info

    st.write("**Tables:**", ", ".join(info.get("tables", [])))

    # Display structured schema with relationships
    if info.get("structured_schema"):
        with st.expander("ðŸ“Š Table Relationships & Schema", expanded=True):
            structured = info["structured_schema"]

            if "tables" in structured:
                for table_name, table_info in structured["tables"].items():
                    st.markdown(f"### {table_name}")

                    # Table purpose
                    if table_info.get("purpose"):
                        st.markdown(f"**Purpose:** {table_info['purpose']}")

                    # Columns with inferred meanings
                    if table_info.get("columns"):
                        st.markdown("**Columns:**")
                        for col in table_info["columns"]:
                            col_name = col.get("name", "unknown")
                            col_type = col.get("type", "")
                            col_meaning = col.get("meaning", "")
                            col_patterns = col.get("patterns", "")

                            st.markdown(f"- **{col_name}** ({col_type})")
                            if col_meaning:
                                st.markdown(f"  - *Meaning:* {col_meaning}")
                            if col_patterns:
                                st.markdown(f"  - *Pattern:* {col_patterns}")

                    # Relationships
                    if table_info.get("relationships"):
                        st.markdown("**Relationships:**")
                        for rel in table_info["relationships"]:
                            rel_type = rel.get("type", "unknown")
                            rel_ref = rel.get("references", "")
                            rel_desc = rel.get("description", "")
                            st.markdown(f"- {rel_type}: {rel_ref}")
                            if rel_desc:
                                st.markdown(f"  - {rel_desc}")

                    st.divider()

    # Display data dictionary (escape dollar signs to prevent LaTeX rendering)
    if info.get("data_dictionary"):
        with st.expander("ðŸ“– Data Dictionary (Auto-Generated)", expanded=False):
            st.markdown(escape_dollar_signs(info["data_dictionary"]))
